#!/usr/bin/env python3
import logging
import argparse
import re
import sys
import os
import pathlib
import time
import shutil
from typing import Dict, List, Tuple, Any


from rich.traceback import install
from rich.logging import RichHandler
from rich.progress import track

#########################################################################
# Support/interface function
#########################################################################


def setup_logging(verbosity: int, excluded_modules: List[str] = []):
    """Set-up root logging level according to the number of -v options
    Logging can also be set to be quiet for imported modules
    """
    for module in excluded_modules:
        logging.getLogger("docpie").setLevel(logging.WARNING)

    logging_level = logging.WARNING
    if verbosity == 1:
        logging_level = logging.INFO
    if verbosity and verbosity >= 2:
        logging_level = logging.DEBUG
    FORMAT = "[%(funcName)20s() ] %(levelname)s %(message)s"  # noqa: E501
    logging.basicConfig(
        level=logging_level,
        format=FORMAT,
        datefmt="[%X]",
        handlers=[RichHandler()],
    )

    log = logging.getLogger("rich")
    return log


def get_args():
    """
    Get command line arguments
    """

    parser = argparse.ArgumentParser(
        description="""
    Create a directory structure to store 1000s of assemly files generated by riscv-torture
                   """
    )

    parser.add_argument(
        "--nospinner",
        action="store_true",
        help="Disable fancy display using color and icons",
        required=False,
        default=None,
    )
    parser.add_argument(
        "--target_dir",
        action="store",
        help="Directory under which the directory structure will be created",
        required=False,
        default="output_dir",
    )

    parser.add_argument(
        "--source_dir",
        action="store",
        help="Directory where the assembly programs are stored",
        required=False,
        default="./output",
    )

    parser.add_argument(
        "--max_entries",
        action="store",
        help="Maximum number of entries in each subdirectory",
        type=int,
        required=False,
        default=10,
    )

    parser.add_argument(
        "-v", "--verbosity", action="count", help="Increase output verbosity"
    )
    parser.add_argument("--version", action="version", version="%(prog)s 0.1")

    return parser.parse_args()


# convert a number in a string that represent
# https://stackoverflow.com/questions/2267362/how-to-convert-an-integer-to-a-string-in-any-base


def numberToBase(n, b):
    if n == 0:
        return [0]
    digits = []
    while n:
        digits.append(int(n % b))
        n //= b
    return digits[::-1]


def array2path(a: List[int], max_digits: int):
    """transform an array into a path

    [51,12,1] =>  051/012/001

    """
    a_l = [str(x).zfill(max_digits) for x in a]
    return "/".join(a_l)


def main():
    MIN_PYTHON = (3, 6)
    if sys.version_info < MIN_PYTHON:
        sys.exit("Python %s.%s or later is required.\n" % MIN_PYTHON)

    cmdline = " ".join(sys.argv)
    args = get_args()
    use_spinner = not args.nospinner
    log = setup_logging(args.verbosity)

    log.debug("Application started !")
    install()  # rich nicer traceback

    log.debug(f"Command line {cmdline}")

    s_dir = pathlib.Path(args.source_dir)

    s_files = list(s_dir.glob("*.S"))

    all_indexes = []

    all_files = dict()

    for f in s_files:
        # look for the index in the file name
        # (torture uses always the same scheme to number the files)
        match = re.search(r"\d+", str(f))
        if match:
            idx = int(match.group(0))
            all_indexes.append(int(idx))
            all_files[idx] = {"origin": str(f)}
    first_idx, last_idx = (min(all_indexes), max(all_indexes))

    # maximum level of directories
    max_depth = len(numberToBase(last_idx, args.max_entries))
    log.debug(f"first_idx = {first_idx}")
    log.debug(f"last_idx = {last_idx}")
    log.debug(f"max_depth = {max_depth}")

    # how many digits we need to represent a directory name
    max_digits = len(numberToBase(args.max_entries - 1, 10))
    log.debug(f"max_digits = {max_digits}")

    # for each file, we compute the destination path depending of its
    # index
    for idx in all_indexes:
        target = numberToBase(idx, args.max_entries)
        l_target = len(target)
        padding = max_depth - l_target
        # if number of subdirectory is smaller than the "max" one
        # we pad with 0
        if padding > 0:
            target = [0] * (padding) + target
        all_files[idx].update(
            {
                "destination": args.target_dir
                + "/"
                + array2path(target, max_digits)
            }
        )

    # And now we do the actual copy"
    for idx in track(all_indexes, "Copying files"):
        src = all_files[idx]["origin"]
        dest = all_files[idx]["destination"]
        os.makedirs(dest, exist_ok=True)
        shutil.copy(src, dest)


if __name__ == "__main__":
    main()


# Local Variables:
# eval: (blacken-mode)
# End:
